### 前后台进程切换的命令  
```shell
>>./server | ./client &
>>jobs
>>fg 1
>>bg 2
jobs 查看当前有多少在后台运行的命令
fg: 将后台进程切到前台
bg: 可以让某个停止的作业在后台继续运行
ctrl + z :将一个正在前台执行的命令放到后台，并且暂停  、

```
### 守护进程  
守护进程也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件  
使用命令**ps**列出的进程，在TPGID一栏写着-1的都是没有控制终端的进程，也就是守护进程。   
另外在**COMMAND**一栏中用**[]**括起来的名字标识内核线程，通常以k开头的名字。  

- 守护进程的创建  
    - 1、设置文件掩码为0 
    - 2、fork后终止父进程，子进程创建新会话  
    - 3、忽略SIGCHLD信号 
    - 4、再次fork，种植父进程，保持子进程不是会话首进程，从而保证后续不会和其他终端相关联。  
    - 5、更改工作目录为根目录
    - 6、将标准输入、标准输出、标准错误重定向到/dev/null

- 说明
    - 将文件掩码设置为0，保证后续守护进程创建文件时，创建出来的文件的权限符合我们的预期）
    - 调用setsid创建新会话的目的，是让当前进程自成会话，与当前bash脱离关系（创建守护进程的核心）
    - 调用setsid创建新会话时，要求调用进程不能是进程组组长，但是当我们在命令行上启动多个进程协同完成某种任务时，其中第一个被创建出来的进程就是组长进程，因此我们需要fork创建子进程，让子进程调用setsid创建新会话并继续执行后续代码，而父进程我们直接让其退出即可） 
    - 守护进程不能直接和用户交互，也就没有必要再打开某个终端了，而打开一个终端需要你是会话首进程，为了防止守护进程打开终端，我们需要再次fork创建子进程并让子进程继续执行后续代码，由于子进程不是会话首进程，也就没有能力打开其他终端了，而父进程我们直接让其退出即可。（这是一种防御性编程，该操作不是必须的）
    - 我们一般会将守护进程的工作目录设置为根目录，便于让守护进程以绝对路径的形式访问某种资源。（该操作不是必须的）
    - 守护进程不能直接和用户交互，也就是说守护进程已经与终端去关联了，因此一般我们会将守护进程的标准输入、标准输出以及标准错误都重定向到/dev/null，/dev/null是一个字符文件（设备），通常用于屏蔽/丢弃输入输出信息。（该操作不是必须的）


- 手动创建守护进程实例 
```C
#include <fcntl.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdlib.h>
int main()
{
	//1、设置文件掩码为0
	umask(0);

	//2、fork后终止父进程，子进程创建新会话
	if (fork() > 0){
		//father
		exit(0);
	}
	setsid();

	//3、忽略SIGCHLD信号
	signal(SIGCHLD, SIG_IGN);

	//4、再次fork，终止父进程，保持子进程不是会话首进程，从而保证后续不会再和其他终端相关联
	//（不是必须的，防御性编程）
	if (fork() > 0){
	    //father
		exit(0);
	}

	//5、更改工作目录为根目录（可选的选项）
	chdir("/");

	//6、将标准输入、标准输出、标准错误重定向到/dev/null（可选的选项）
	close(0);
	int fd = open("/dev/null", O_RDWR);
	dup2(fd, 1);
	dup2(fd, 2);
	
	while (1);
	return 0;
}

```


- 调用**daemon**函数创建守护进程  
`int daemon(int nochdir, int noclose)`  
如果参数nochdir为0，则守护进程的根目录该为根目录，否则不做处理。  
如果参数noclose为0，则标准输入输出重定向到/dev/null  
调用实例:
```C
#include<unistd.h>
int main()
{
    daemon(0,0);
    while(1);
    return 0;
}
```