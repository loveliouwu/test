# 密码学实践

## 名词术语

CA：证书机构

PKI：公钥基础设施

## 密码学简介

### Kerckhoffs原理

>加密方案的安全性必须仅仅依赖于K的保密性，而不依赖于算法的保密性
>

公钥加密私钥解密即非对称加密的速度太慢，因此通常不直接用来加密数据，而是通过对称加密。
公钥算法用来建立一个秘密密钥，该秘密密钥用来加密真正的数据。

### 数字签名

>数字签名是消息认证码再公钥情形下的等价形式，
>
>A使用密钥生成算法产生一个密钥对(S_a,P_a)(私钥，公钥)，并公开他的公钥P_a,当他要发送带签名的消息m给B时，通过计算确定签名s=f(S_a,m)，发送m和s给B，B利用A的公钥P_a通过签名验证算法来验证签名，签名的工作机制类似于MAC，不同的是B可以利用公钥进行验证，而产生一个新的签名却需要私钥
>

### PKI

>虽然公钥密码学使密钥管理变得简单，但是A仍然要找到B的公钥，他怎么相信那是B的公钥，而不是其他人的公钥呢，一般解决办法是利用PKI，或者称为公钥基础设施
>
>主要思想是使用一个中心机构，称为证书机构或者CA
>

### 攻击

1. 惟密文攻击
2. 已知明文攻击
3. 选择明文攻击
4. 选择密文攻击
5. 区分攻击
6. 生日攻击 -->碰撞攻击
7. 中间相遇攻击 -->碰撞攻击

## 消息的安全性

### 分组密码

分组密码是定义在长度固定的明文块上的加密函数，在分组密码中，密文块与明文块的大小相同，称为分组密码的**分组长度**

现在一般的分组密码明文块的长度一般为128比特(16字节)，它对128比特的明文块加密，生成128比特的密文，**分组密码是可逆的**，即存在一个解密函数，可以由128比特的密文得到128比特的原明文

密钥长度一般为128比特或者256比特，分组密码主要用于信息的加密，对于较短的消息可以直接用分组密码进行加密，但对比其分组长度还长的消息，加密需要使用**分组密码模式**

根据Kerckhoffs原理，我们总是假定加密和解密算法是公开的。

可以将分组密码看成一个依赖于密钥的明文与密文对照表，但这这个表可能十分庞大，128比特的分组密码，对应的表大小位5*10^39

实际上所有的分组密码都是由一个弱的分组密码重复几次构成的，每一次重复称为一轮，这种由几个弱的伦茨构成一个强的分组密码的结构易于设计和实现，而且也便于分析。

### 实际的分组密码

- DES

DES的密钥长度位56bit，分组长度位64bit，已不适应于现代的快速计算机和庞大的数据量

另外一种分组密码是 3DES 由3个DES加密序列组成，是DES的另外一种形式，它解决的DES的小密钥问题，但没有解决小的分组长度问题，DES的速度还不够快，而3DES速度仅为DES的1/3

    - DES的单轮结构
    DES首先将长度位64比特的明文的每一比特位用"半有序"的方式重新排列(即对明文做一个初始的置换)，并将其分为两个32比特的块，按位置左边的一般记为L0，右边记为R0，然后进行加密运算，在加密的最后用初始置换的逆置操作得到64比特的密文，这个初始的置换并没有密码学上的意义

DES共有16轮，每一轮都有一个48比特长的轮密钥，在轮密钥Ki的控制下，第i轮由(Li,Ri)得到(Li+1,Ri+1),这主要由轮函数F完成

    - 轮函数F的过程
    首先用一个扩展函数复制若干比特从而将32比特的Ri扩展位48比特，然后与Ki做异或运算，结果经过称为S盒的变换后变成32比特，再用一个置换作用后与Li做异或得到Li+1，而Ri+1=Li，S盒是一个公开的对照表，由8个将6比特的串映射为4比特的串的较小的表构成，从而实现了从48比特到32比特的变换

DES的密钥方案是：采用不同的选择方法，DES为每一轮加密从56比特的系统密钥中选择48位作为轮密钥

    - S盒提供了非线性
    如果没有这种非线性，加密可以表示为一系列的异或运算，从而会发生一个非常简单的基于线性代数的攻击
    S盒、扩展函数、置换操作保证了DES的扩展性，由此是的如果轮函数输入有1比特发生了改变，则其输出的多个比特都将发生变化，从而在下一轮将会有更多的比特发生变化，如果没有良好的扩散性，必将导致明文的小改变只会引起密文的小变化，这很容易被检测出来

- AES

高级加密标准(AES)是新的美国政府标准，上一轮的输出作为下一轮的输入而加密运算根据密钥的大小由10~14轮组成

    - AES轮流程
    明文的长度为16字节，首先将其与16个字节的轮密钥进行异或运算，结果再按字节输入将8比特映射为8比特的S盒，所有字节对应的S盒都相同，然后将这16字节用一个指定的顺序重新排列，最后分为4个组分别用线性混合函数进行混合，这里的线性指的是输出是几个输入的异或

AES的结构有一些好的方面，但是也有一些不足，AES每一步针对字节的运算都是可以并行地完成，从而便于算法的高速实现，但另一方面，它的解密运算与加密运算有很大的差别，解密时需要S盒的逆。

### 分组密码模式

- 填充

分组密码模式是将任意长度明文P加密产生密文C的一种方法，大部分模式都要求明文长度刚好是分组大小的整数倍，因此需要对明文P进行填充

    - 填充方法
    方法1：首先添加值为128的一个字节，即添加一个0x80，然后添加一些0字节使得总长度为分组密码分组长的的倍数。
    例如b = 16, P = {0~0xa}
    填充后
    P' = {0~0xa,0x80,0x0,0x0,0x0,0x0}
    方法2：首先确定需要填充的字节数n，选择1<=n<=b (b为分组长度)，使得n+l (l是明文P的字节数)是b的背书，然后填充n个值为n的字节。
    P' = {0~0xa,0x5,0x5,0x5,0x5,0x5}

完成填充后明文分成许多块，这样明文P就变成块序列P1~Pn

- ECB

最简单的加密长明文的方法称为**电子密码本模式**(ECB,electronic codebook),即用加密算法分别加密每一个明文块，但是ECB有严重的缺陷，ECB模式中如果两个明文块相同，则他们对应的密文块也一定相同。

- CBC

**密码分组链接模式**(CBC,cipher block chaining)是一种广泛使用的分组密码模式，它将明文块与前一个密文块进行异或运算，然后再加密得到对应的密文块，从而客服了ECB的缺陷。这相当于用前一个密文块对当前的明文块进行了随机化，因此相同的明文块将对应不同的密文块，从而大大减少了信息的泄露

    - 固定初始向量IV
    使用CBC模式还有一个问题，即要确定C0的值，这个值称为初始向量,不应使用固定的IV，否则对每一个消息的第一块就会出现ECB的问题。

    -计数IV
    我们知道的一个可供选择的方法是使用计数IV，对第一个消息，让IV=0，对第二个，让IV=1，然而这也不是一个好的主意。

    - 随机IV
    电子密码本模式(ECB)与采用固定IV以及计数IV的密码分组链接模式(CBC)存在的问题都源于铭文消息极强的非随机性，明文通常由固定的开头，或由非常清楚的结构，在CBC模式中我们用密文块将明文块"随机化"，但对第一个明文块，则必须使用初始化向量IV将其随机化，因此应当采取随机的IV，随机的IV的问题是IV必须让接收者知道，如此才能正确的解密，标准的解决方案是算则随机IV并作为第一个密文块放在消息对应的密文之前发送给接收者

    - 瞬时IV
    典型的顺式值是消息的某种编号，或编号与其他信息结合构成。根据编号构造一个唯一的瞬时值，大小为分组密码的分组长度，对瞬时值加密得到IV，用这个IV在CBC模式下对消息加密，在密文上附加足够多的信息，以使接收者嗯呢恢复这个瞬时值，一般是在密文的前面附加上消息编号，IV本身不必发送。

- OFB

**输出反馈模式(OFB，output feedback)**区别与ECB、CBC模式的接受消息，然后以某种方式用分组密码对消息块进行加密方式，OFB首先用分组密码生成一个伪随机字节流(称为密钥流),然后将其与明文进行异或得到密文，这种用生成随机密钥流进行加密的方法称为流密码。
OFB中IV必须是随机的，如同在CBC中一样，IV可以随机的选取并同密文一起发送出去，也可以由一个瞬时值生成。
OFB的一个优点是不需要对明文进行填充，将密钥流当作一个字节序列，加密时可以只使用盒明文一样多的字节，换句话说，如果最后一个明文块的一部分是有效的，那么就可以只发送那些和明文对应的密文字节，多余的可以丢掉，加密前不对明文进行填充减少了系统的开销，这对短消息来说特别重要。

- CTR

计数模式(CTR,counter mode)，也是一种流密码模式，加密是必须使用某种心事的唯一瞬时值，而大多数系统都用消息编号与某些附加信息来生成瞬时值以保证唯一性。

CTR生成密钥流的方法很简单，首先将瞬时值与计数值连接起来（连接后的长度应该小于一个块的长度如128bit），然后对此进行加密产生密钥流的一个密钥块，对于128比特的分组，典型的比特分配方案时消息编号占48比特，瞬时值的附加数据占16比特，而其余64比特用于计数器i，这样将限定系统是哟个一个密钥只能加密2^48个不同的消息，而每个消息最多能有2^68个字节。

同OFB模式一样，CTR模式中绝不能重复使用一个密钥和瞬时值的组合，所以在使用CBC和CTR时，必须保证IV或瞬时值的唯一性。

另外CTR模式很容易使用，仅需实现分组密码的加密函数即可，因为它的加密函数与解密函数一样。同事CTR模式的密钥流中的任意一个密钥块都可以即时计算，因此可以非常容易的获取明文的任意一部分。

- OCB

- CBC和CTR和选择

CTR比OFB在某些方面好，ECB不够安全

    - 填充：CBC需要对消息进行填充，而CTR不需要
    - 速度：两种模式都由相同的计算量，但CTR允许进行任意的并行计算，因此可以获得更高的速度
    - 实现：CTR仅需要分组密码的加密函数，而CBC则要求同时实现分组密码的加密函数和解密函数
    - 健壮性：如果重复使用了一个相同的瞬时值，CBC可能会泄露有关原始明文块的一些信息，而CTR将泄露有关整个消息的信息
    - 瞬时值：CBC可以使用随机IV或一个瞬时值，而CTR要求由唯一的瞬时值，但在实际使用时，CBC模式的加密总是使用一个瞬时值，因此在这一方面两个模式相同

由此可见，除了健壮性外，CTR在几个方面都占优，而在大多是剧痛中，设计者可以自己设计瞬时系统，因此很容易克服瞬时值重复的问题。所以CTR比CBC更应该被选择。

## Hash函数

Hash函数是所有密码学基元中用途最多的一个，它可以用于加密、认证，甚至可以构造简单的数字签名方案。

Hash函数的输入是任意长度的比特或字节串，而输出是固定长度的对应串，Hash函数的一个典型的应用是数字签名，对给定消息m，我们可以直接对这个消息本身进行签名，然而，大多数数字签名在用于公钥运算方面的开销相当大，直接对消息本身签名很不经济，因此可以先对消息m应用Hash函数h，然后对h(m)进行签名,Hash函数的输出一般在128比特到512比特之间，与很长的消息m相比，对h(m)签名比对消息m直接签名要快得多

Hash函数有时又称为消息摘要函数，其值叫做摘要或者指纹，

- Hash函数的安全性

Hash要满足几个条件，最基本的是它必须是单向函数即不能通过结果推导出消息，抗碰撞性即h(m1)始终不等于h(m2)

理想的Hash函数是从所有可能的输入值到有限可能的输出值结合的一个随机映射

- 实际的Hash函数

好的Hash函数很少，于是通常在SHA系列或者MD5中选择，现实的Hash函数几乎都是迭代Hash函数

- MD5

MD5是一个128比特的Hash函数，它在MD4的基础上强化了抗攻击能力

计算MD5的第一步是将消息分为512比特的块序列，对最后一个块要进行填充，消息的长度信息也在其中，MD5有128比特的状态变量

对大鼠应用来说MD5的128比特的长度是不够的，由生日悖论可知，对Hash函数大约进行2^64次运算就可以找到一个膨胀，对现代的密码系统来说这是不够的

- SHA-1

NSA设计了安全的Hash算法，